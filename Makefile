# ==============================================================================
# Base Makefile - Git Worktree Commands
# Generated by overlord - Do not edit manually (use overlord sync)
# ==============================================================================

.PHONY: help worktree-new worktree-list worktree-remove worktree-setup \
        worktree-attach worktree-sessions worktree-send worktree-read \
        tmux-send tmux-read tmux-list \
        _create_worktree_session

# Default worktree directory (inside project)
WORKTREE_DIR := .worktrees

# Counter file for auto-generated worktree names
COUNTER_FILE := $(WORKTREE_DIR)/.counter

# Shell functions for counter management
define read_counter
$(shell [ -f $(COUNTER_FILE) ] && cat $(COUNTER_FILE) || echo 0)
endef

define increment_counter
$(shell \
	mkdir -p $(WORKTREE_DIR); \
	COUNTER=$$([ -f $(COUNTER_FILE) ] && cat $(COUNTER_FILE) || echo 0); \
	NEXT=$$((COUNTER + 1)); \
	echo $$NEXT > $(COUNTER_FILE); \
	echo $$COUNTER \
)
endef

# Word lists for name generation (20 adjectives Ã— 20 nouns = 400 combinations)
ADJECTIVES := swift bright clever smooth quick clean sharp neat cool fast \
              bold calm clear crisp fresh light prime ready smart steady

NOUNS := fix task work dev patch branch code build test run \
         flow sync push pull draft spike probe check scan forge

# Generate deterministic name from counter
# Usage: $(call generate_name,counter_value)
define generate_name
$(shell \
	COUNTER=$(1); \
	ADJECTIVES="swift bright clever smooth quick clean sharp neat cool fast bold calm clear crisp fresh light prime ready smart steady"; \
	NOUNS="fix task work dev patch branch code build test run flow sync push pull draft spike probe check scan forge"; \
	ADJ_ARRAY=($$ADJECTIVES); \
	NOUN_ARRAY=($$NOUNS); \
	ADJ_IDX=$$((COUNTER % 20)); \
	NOUN_IDX=$$((COUNTER / 20 % 20)); \
	printf "%s_%s_%02d" "$${ADJ_ARRAY[$$ADJ_IDX]}" "$${NOUN_ARRAY[$$NOUN_IDX]}" $$COUNTER \
)
endef

# Check if tmux session exists
# Usage: $(call session_exists,session_name)
define session_exists
$(shell tmux has-session -t $(1) 2>/dev/null && echo 1 || echo 0)
endef

# Generate unique name (handles collisions)
# Returns: unique_name
define generate_unique_name
$(shell \
	COUNTER=$$($(increment_counter)); \
	NAME=$$($(call generate_name,$$COUNTER)); \
	while [ "$$($(call session_exists,$$NAME))" = "1" ]; do \
		NAME="$${NAME}_$$COUNTER"; \
	done; \
	echo $$NAME \
)
endef

# Show available commands
help:
	@echo "Worktree + Tmux Commands:"
	@echo ""
	@echo "Worktree Management:"
	@echo "  make worktree-new [BRANCH=<name>]        Create worktree + tmux session (auto-names if BRANCH omitted)"
	@echo "  make worktree-list                       List all worktrees"
	@echo "  make worktree-remove BRANCH=<name>       Remove worktree and kill tmux session"
	@echo "  make worktree-setup                      Run .worktree-setup.sh in current directory"
	@echo ""
	@echo "Tmux Session Management:"
	@echo "  make worktree-attach BRANCH=<name>       Attach to worktree's tmux session"
	@echo "  make worktree-sessions                   List tmux sessions for all worktrees"
	@echo ""
	@echo "Cross-Session Communication:"
	@echo "  make worktree-send BRANCH=<name> WINDOW=<window> CMD=\"<command>\""
	@echo "                                           Send command to worktree session window"
	@echo "  make worktree-read BRANCH=<name> WINDOW=<window>"
	@echo "                                           Read visible pane content from worktree"
	@echo ""
	@echo "Current Session Utilities (run from within tmux):"
	@echo "  make tmux-send WINDOW=<window> CMD=\"<command>\""
	@echo "                                           Send command to current session window"
	@echo "  make tmux-read WINDOW=<window>           Read visible pane content from window"
	@echo "  make tmux-list                           List all windows in current session"
	@echo ""
	@echo "Examples:"
	@echo "  make worktree-new                        Create worktree with auto-generated name"
	@echo "  make worktree-new BRANCH=fix-auth        Create worktree named 'fix-auth'"
	@echo "  make tmux-send WINDOW=shell CMD=\"make test\""
	@echo "  make tmux-read WINDOW=shell              Read test output"
	@echo "  make tmux-list                           Show available windows"
	@echo "  make worktree-send BRANCH=fix-auth WINDOW=shell CMD=\"make test\""
	@echo "  make worktree-attach BRANCH=fix-auth     Attach to 'fix-auth' session"
	@echo ""

# Create a new worktree with tmux session
# Usage: make worktree-new [BRANCH=<name>]
# If BRANCH omitted, generates name automatically
worktree-new:
	@# Determine branch name (auto-generate or use provided)
	@BRANCH_NAME="$(BRANCH)"; \
	if [ -z "$$BRANCH_NAME" ]; then \
		COUNTER=$$($(increment_counter)); \
		BRANCH_NAME=$$($(call generate_name,$$COUNTER)); \
		while tmux has-session -t "$$BRANCH_NAME" 2>/dev/null; do \
			BRANCH_NAME="$${BRANCH_NAME}_$$COUNTER"; \
		done; \
		echo "Auto-generated name: $$BRANCH_NAME"; \
	fi; \
	\
	WORKTREE_PATH="$(WORKTREE_DIR)/$$BRANCH_NAME"; \
	BRANCH_CREATED=0; \
	\
	mkdir -p $(WORKTREE_DIR); \
	\
	if git show-ref --verify --quiet refs/heads/$$BRANCH_NAME; then \
		echo "Branch '$$BRANCH_NAME' exists, creating worktree..."; \
		if ! git worktree add $$WORKTREE_PATH $$BRANCH_NAME 2>/dev/null; then \
			echo "Error: Failed to create worktree"; \
			exit 1; \
		fi; \
	else \
		echo "Creating new branch '$$BRANCH_NAME' and worktree..."; \
		if ! git worktree add -b $$BRANCH_NAME $$WORKTREE_PATH 2>/dev/null; then \
			echo "Error: Failed to create worktree"; \
			exit 1; \
		fi; \
		BRANCH_CREATED=1; \
	fi; \
	\
	if [ -f .gitignore ]; then \
		echo "Copying .gitignore to worktree..."; \
		cp .gitignore $$WORKTREE_PATH/; \
	fi; \
	\
	if [ -f .worktree-setup.sh ]; then \
		echo "Running .worktree-setup.sh..."; \
		chmod +x .worktree-setup.sh; \
		if ! (cd $$WORKTREE_PATH && ../.worktree-setup.sh); then \
			echo "Error: Setup script failed, rolling back..."; \
			git worktree remove --force $$WORKTREE_PATH 2>/dev/null || true; \
			if [ $$BRANCH_CREATED -eq 1 ]; then \
				git branch -D $$BRANCH_NAME 2>/dev/null || true; \
			fi; \
			exit 1; \
		fi; \
	else \
		echo "Warning: No .worktree-setup.sh found (continuing anyway)"; \
	fi; \
	\
	echo "Creating tmux session: $$BRANCH_NAME"; \
	$(MAKE) _create_worktree_session BRANCH=$$BRANCH_NAME WORKTREE_PATH=$$WORKTREE_PATH; \
	\
	echo ""; \
	echo "Worktree created successfully!"; \
	echo "  Branch: $$BRANCH_NAME"; \
	echo "  Path: $$WORKTREE_PATH"; \
	echo "  Session: $$BRANCH_NAME"; \
	echo ""; \
	echo "Attach with: make worktree-attach BRANCH=$$BRANCH_NAME"

# Internal: Create tmux session for worktree (called by worktree-new)
# Usage: make _create_worktree_session BRANCH=name WORKTREE_PATH=path
_create_worktree_session:
	@SESSION="$(BRANCH)"; \
	WORKTREE_DIR="$(WORKTREE_PATH)"; \
	\
	if tmux has-session -t "$$SESSION" 2>/dev/null; then \
		echo "Note: Tmux session '$$SESSION' already exists"; \
		exit 0; \
	fi; \
	\
	tmux new-session -d -s "$$SESSION" -c "$$WORKTREE_DIR" -n base; \
	\
	LOCAL_RC="$$WORKTREE_DIR/.tmux.local"; \
	MODE="override"; \
	\
	if [ -f "$$LOCAL_RC" ]; then \
		MODE_LINE=$$(grep -E '^[[:space:]]*MODE=' "$$LOCAL_RC" 2>/dev/null | head -n1 || true); \
		if [ -n "$$MODE_LINE" ]; then \
			MODE=$$(echo "$$MODE_LINE" | sed -E 's/^[[:space:]]*MODE=//; s/[[:space:]]*$$//'); \
		fi; \
	fi; \
	\
	if [ -f "$$LOCAL_RC" ] && [ "$$MODE" = "override" ]; then \
		TMUX_SESSION="$$SESSION" TMUX_PROJECT_DIR="$$WORKTREE_DIR" bash "$$LOCAL_RC"; \
	else \
		tmux rename-window -t "$${SESSION}:base" "editor"; \
		tmux send-keys -t "$${SESSION}:editor" "nvim" C-m; \
		tmux new-window -t "$$SESSION:" -n shell -c "$$WORKTREE_DIR"; \
		tmux new-window -t "$$SESSION:" -n git -c "$$WORKTREE_DIR"; \
		tmux send-keys -t "$${SESSION}:git" "git status" C-m; \
		\
		if [ -f "$$LOCAL_RC" ] && [ "$$MODE" = "merge" ]; then \
			TMUX_SESSION="$$SESSION" TMUX_PROJECT_DIR="$$WORKTREE_DIR" bash "$$LOCAL_RC"; \
		fi; \
	fi; \
	\
	tmux select-window -t "$${SESSION}:editor"

# List all worktrees
worktree-list:
	@git worktree list

# Remove a worktree and kill its tmux session
# Usage: make worktree-remove BRANCH=<name>
worktree-remove:
ifndef BRANCH
	$(error BRANCH is required. Usage: make worktree-remove BRANCH=<branch-name>)
endif
	@echo "Removing worktree and tmux session: $(BRANCH)"; \
	\
	if tmux has-session -t "$(BRANCH)" 2>/dev/null; then \
		echo "Killing tmux session: $(BRANCH)"; \
		tmux kill-session -t "$(BRANCH)"; \
	else \
		echo "No tmux session found: $(BRANCH)"; \
	fi; \
	\
	if [ -d "$(WORKTREE_DIR)/$(BRANCH)" ]; then \
		echo "Removing worktree: $(BRANCH)"; \
		git worktree remove $(WORKTREE_DIR)/$(BRANCH); \
		echo "Worktree removed: $(BRANCH)"; \
	else \
		echo "Warning: Worktree directory not found: $(WORKTREE_DIR)/$(BRANCH)"; \
	fi; \
	\
	echo "Cleanup complete: $(BRANCH)"

# Attach to worktree's tmux session
# Usage: make worktree-attach BRANCH=<name>
worktree-attach:
ifndef BRANCH
	$(error BRANCH is required. Usage: make worktree-attach BRANCH=<branch-name>)
endif
	@if ! tmux has-session -t "$(BRANCH)" 2>/dev/null; then \
		echo "Error: Tmux session '$(BRANCH)' does not exist"; \
		echo "Create worktree first: make worktree-new BRANCH=$(BRANCH)"; \
		exit 1; \
	fi; \
	\
	if [ -n "$$TMUX" ]; then \
		echo "Switching to session: $(BRANCH)"; \
		tmux switch-client -t "$(BRANCH)"; \
	else \
		echo "Attaching to session: $(BRANCH)"; \
		tmux attach -t "$(BRANCH)"; \
	fi

# List tmux sessions for all worktrees
# Usage: make worktree-sessions
worktree-sessions:
	@echo "Tmux sessions for worktrees:"; \
	echo ""; \
	if ! git worktree list --porcelain 2>/dev/null | grep -q '^worktree'; then \
		echo "No worktrees found"; \
		exit 0; \
	fi; \
	\
	git worktree list --porcelain | while IFS= read -r line; do \
		if echo "$$line" | grep -q '^worktree'; then \
			WORKTREE_PATH=$$(echo "$$line" | sed 's/^worktree //'); \
			BRANCH_NAME=$$(basename "$$WORKTREE_PATH"); \
			\
			if echo "$$WORKTREE_PATH" | grep -q "$(WORKTREE_DIR)"; then \
				if tmux has-session -t "$$BRANCH_NAME" 2>/dev/null; then \
					WINDOWS=$$(tmux list-windows -t "$$BRANCH_NAME" 2>/dev/null | wc -l); \
					ATTACHED=$$(tmux list-sessions 2>/dev/null | grep "^$$BRANCH_NAME:" | grep -o 'attached' || echo "detached"); \
					printf "  %-30s  %d windows  %s\n" "$$BRANCH_NAME" $$WINDOWS "$$ATTACHED"; \
				else \
					printf "  %-30s  (no session)\n" "$$BRANCH_NAME"; \
				fi; \
			fi; \
		fi; \
	done; \
	echo ""

# Run setup script in current worktree
# Looks for .worktree-setup.sh in the project root
worktree-setup:
	@if [ -f .worktree-setup.sh ]; then \
		echo "Running .worktree-setup.sh..."; \
		chmod +x .worktree-setup.sh && ./.worktree-setup.sh; \
	else \
		echo "No .worktree-setup.sh found. Create one for custom setup."; \
	fi

# Send command to worktree's tmux session window
# Usage: make worktree-send BRANCH=<name> WINDOW=<window> CMD="<command>"
worktree-send:
ifndef BRANCH
	$(error BRANCH is required. Usage: make worktree-send BRANCH=<name> WINDOW=<window> CMD="<command>")
endif
ifndef WINDOW
	$(error WINDOW is required. Usage: make worktree-send BRANCH=<name> WINDOW=<window> CMD="<command>")
endif
ifndef CMD
	$(error CMD is required. Usage: make worktree-send BRANCH=<name> WINDOW=<window> CMD="<command>")
endif
	@SESSION="$(BRANCH)"; \
	WINDOW_NAME="$(WINDOW)"; \
	COMMAND="$(CMD)"; \
	\
	if ! tmux has-session -t "$$SESSION" 2>/dev/null; then \
		echo "Error: Tmux session '$$SESSION' does not exist"; \
		echo ""; \
		echo "Available worktree sessions:"; \
		$(MAKE) worktree-sessions 2>/dev/null || echo "  (none)"; \
		exit 1; \
	fi; \
	\
	if ! tmux list-windows -t "$$SESSION" 2>/dev/null | grep -q "^[0-9]*: $$WINDOW_NAME"; then \
		echo "Error: Window '$$WINDOW_NAME' does not exist in session '$$SESSION'"; \
		echo ""; \
		echo "Available windows in '$$SESSION':"; \
		tmux list-windows -t "$$SESSION" 2>/dev/null | awk '{print "  " $$2}' | sed 's/\*$$//'; \
		exit 1; \
	fi; \
	\
	echo "Sending to $$SESSION:$$WINDOW_NAME: $$COMMAND"; \
	tmux send-keys -t "$$SESSION:$$WINDOW_NAME" "$$COMMAND" C-m

# Read visible pane content from worktree's tmux session window
# Usage: make worktree-read BRANCH=<name> WINDOW=<window>
worktree-read:
ifndef BRANCH
	$(error BRANCH is required. Usage: make worktree-read BRANCH=<name> WINDOW=<window>)
endif
ifndef WINDOW
	$(error WINDOW is required. Usage: make worktree-read BRANCH=<name> WINDOW=<window>)
endif
	@SESSION="$(BRANCH)"; \
	WINDOW_NAME="$(WINDOW)"; \
	\
	if ! tmux has-session -t "$$SESSION" 2>/dev/null; then \
		echo "Error: Tmux session '$$SESSION' does not exist"; \
		echo ""; \
		echo "Available worktree sessions:"; \
		$(MAKE) worktree-sessions 2>/dev/null || echo "  (none)"; \
		exit 1; \
	fi; \
	\
	if ! tmux list-windows -t "$$SESSION" 2>/dev/null | grep -q "^[0-9]*: $$WINDOW_NAME"; then \
		echo "Error: Window '$$WINDOW_NAME' does not exist in session '$$SESSION'"; \
		echo ""; \
		echo "Available windows in '$$SESSION':"; \
		tmux list-windows -t "$$SESSION" 2>/dev/null | awk '{print "  " $$2}' | sed 's/\*$$//'; \
		exit 1; \
	fi; \
	\
	echo "Reading from $$SESSION:$$WINDOW_NAME:"; \
	echo "----------------------------------------"; \
	tmux capture-pane -t "$$SESSION:$$WINDOW_NAME" -p

# Send command to window in current tmux session
# Usage: make tmux-send WINDOW=<window> CMD="<command>"
tmux-send:
ifndef WINDOW
	$(error WINDOW is required. Usage: make tmux-send WINDOW=<window> CMD="<command>")
endif
ifndef CMD
	$(error CMD is required. Usage: make tmux-send WINDOW=<window> CMD="<command>")
endif
	@if [ -z "$$TMUX" ]; then \
		echo "Error: Not running inside tmux session"; \
		echo ""; \
		echo "This command must be run from within a tmux session."; \
		echo "Use 'overlord open' or 'make worktree-attach' to enter a session."; \
		exit 1; \
	fi; \
	\
	SESSION=$$(tmux display-message -p '#S'); \
	WINDOW_NAME="$(WINDOW)"; \
	COMMAND="$(CMD)"; \
	\
	if ! tmux list-windows -t "$$SESSION" 2>/dev/null | grep -q "^[0-9]*: $$WINDOW_NAME"; then \
		echo "Error: Window '$$WINDOW_NAME' does not exist in current session '$$SESSION'"; \
		echo ""; \
		echo "Available windows:"; \
		tmux list-windows -t "$$SESSION" 2>/dev/null | awk '{print "  " $$2}' | sed 's/\*$$//'; \
		exit 1; \
	fi; \
	\
	echo "Sending to $$SESSION:$$WINDOW_NAME: $$COMMAND"; \
	tmux send-keys -t "$$SESSION:$$WINDOW_NAME" "$$COMMAND" C-m

# Read visible pane content from window in current tmux session
# Usage: make tmux-read WINDOW=<window>
tmux-read:
ifndef WINDOW
	$(error WINDOW is required. Usage: make tmux-read WINDOW=<window>)
endif
	@if [ -z "$$TMUX" ]; then \
		echo "Error: Not running inside tmux session"; \
		echo ""; \
		echo "This command must be run from within a tmux session."; \
		echo "Use 'overlord open' or 'make worktree-attach' to enter a session."; \
		exit 1; \
	fi; \
	\
	SESSION=$$(tmux display-message -p '#S'); \
	WINDOW_NAME="$(WINDOW)"; \
	\
	if ! tmux list-windows -t "$$SESSION" 2>/dev/null | grep -q "^[0-9]*: $$WINDOW_NAME"; then \
		echo "Error: Window '$$WINDOW_NAME' does not exist in current session '$$SESSION'"; \
		echo ""; \
		echo "Available windows:"; \
		tmux list-windows -t "$$SESSION" 2>/dev/null | awk '{print "  " $$2}' | sed 's/\*$$//'; \
		exit 1; \
	fi; \
	\
	echo "Reading from $$SESSION:$$WINDOW_NAME:"; \
	echo "----------------------------------------"; \
	tmux capture-pane -t "$$SESSION:$$WINDOW_NAME" -p

# List all windows in current tmux session
# Usage: make tmux-list
tmux-list:
	@if [ -z "$$TMUX" ]; then \
		echo "Error: Not running inside tmux session"; \
		echo ""; \
		echo "This command must be run from within a tmux session."; \
		echo "Use 'overlord open' or 'make worktree-attach' to enter a session."; \
		exit 1; \
	fi; \
	\
	SESSION=$$(tmux display-message -p '#S'); \
	echo "Windows in session '$$SESSION':"; \
	echo ""; \
	tmux list-windows -t "$$SESSION" | while IFS=: read -r index rest; do \
		NAME=$$(echo "$$rest" | awk '{print $$1}' | sed 's/\*$$//'); \
		IS_ACTIVE=$$(echo "$$rest" | grep -q '\*' && echo " (active)" || echo ""); \
		printf "  %s%s\n" "$$NAME" "$$IS_ACTIVE"; \
	done; \
	echo ""

# ==============================================================================
# Python Makefile - UV Commands
# Generated by overlord - Do not edit manually (use overlord sync)
# ==============================================================================

.PHONY: install sync lock run test lint format clean

# Install dependencies
install:
	uv sync

# Sync dependencies (same as install for uv)
sync:
	uv sync

# Update lock file
lock:
	uv lock

# Run the project (adjust as needed)
run:
	uv run python -m $(shell basename $(CURDIR))

# Run tests
test:
	uv run pytest

# Lint code
lint:
	uv run ruff check .

# Format code
format:
	uv run ruff format .

# Clean build artifacts
clean:
	rm -rf __pycache__ .pytest_cache .ruff_cache dist build *.egg-info
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
